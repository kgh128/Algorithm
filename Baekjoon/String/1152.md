# 단어의 개수

## 1. 기본 알고리즘
- 현재 문자가 종결 문자이면 반복문 탈출
    > - cin.get(): 개행 문자('\n')
    > - cin.getline(): 널 문자('\0')
- 이전 문자가 공백이고, 현재 문자가 알파벳이면 단어의 개수 + 1
    > 이는 단어의 시작 부분을 의미하므로



## 2. cin.get() 사용
- iostream에 존재
- 표준 입력 버퍼에서 문자를 하나만 가져옴.
- 공백, 개행 포함
- 문자만 입력 받음.

``` c++
// 깃허브에 없고 백준 제출에만 있는 코드

#include <iostream>
using namespace std;

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n = 0;          //단어의 개수
    char prev = ' ';    // 이전 문자
    char curr;          // 현재 문자 (문자 1개 받을 버퍼)          

    // 1. 단어의 개수 세기
    while (curr != '\n') {
        curr = cin.get();

        // 이전 문자가 공백이고, 현재 문자가 알파벳이면 단어의 시작 부분
        // 따라서 단어의 개수 + 1
        // (문자열의 마지막이 공백이면 가장 마지막에는 prev = ' ', curr = '\n'인 경우가 존재)
        // (따라서 curr != '\n' 조건 추가)
        if (prev == ' ' && curr != '\n' && curr != ' ') {
            n++;
        }

        // 현재 문자를 다음 문자의 이전 문자로 설정
        prev = curr;
    }

    // 2. 단어의 개수 출력
    cout << n << '\n';

}
```

1. cin.get()으로 표준 입력 버퍼에서 문자를 한 개씩 받음.
2. 이전 문자(prev)와 현재 문자(curr)를 검사하여 단어의 시작 부분인지 확인
    > - 이 때, 문자열의 마지막 문자가 공백인 경우, 제일 마지막에 종결 문자('\n')를 읽었을 때
    > - prev = ' ', curr = '\n'으로
    > - prev == ' ' && curr != ' ' 조건이 만족함.
    > - 따라서 curr != '\n' 조건 추가
3. prev를 선언할 때 공백으로 초기화
    > - 문자열의 처음 문자를 검사할 때도 알고리즘이 제대로 동작하도록
    > - 문자열의 처음 문자가 알파벳이면
    > - prev == ' ' && curr != ' ' 조건 충족하여 단어의 개수 + 1이 제대로 됨.
4. while문에서 종결 문자 조건을 확인하여 종결 문자이면 탈출

### [단점]
- 표준 입력 버퍼를 한 번에 받아오지 않고, 문자의 개수만큼 버퍼에 접근
- 따라서, 표준 입력 버퍼를 한 번에 접근하여 받아오는 것보다 시간이 오래 걸리는 것 같음.
    > I/O에 접근하는 것은 시간이 오래걸리니까, 한 번에 접근하는 것보다 여러 번 접근하는 게 더 오래 걸리는 것 같음.



## 3. cin.getline() 사용

- iostream에 존재
- cin.getline(변수의 주소, 최대 입력가능 문자 수, 종결 문자)
    > 세번째 인자(종결 문자)는 선택사항
- 종결 문자를 NULL로 바꿈. 종결 문자 생략시 엔터로 간주.
- 최대 입력 가능 문자 수보다 많은 문자를 입력한 경우 n-1개 만큼 받아들이고, n번째 문자는 NULL로 바꿈.
- 공백, 개행 입력 받음.
- 문자열만 입력받음.
- getline()과는 다른 함수

```c++
#include <iostream>
using namespace std;

int main(void) {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n = 0;              //단어의 개수
    char buf[1000001];      // 문자열을 받을 버퍼

    // 1. 문자열 입력 받기
    // 문자열의 종결 문자는 널문자(\0)
    cin.getline(buf, 1000001); 

    // 1. 단어의 개수 세기
    for (int i = 0; i < 1000000; i++) {
        // 종결 문자 나오면 종료
        if (buf[i] == '\0') break;

        // i = 0일 때 처리 (문자열의 처음 문자)
        // (i-1 접근이 불가능하므로 따로 처리)
        // 알파벳이면 단어의 개수 + 1 (단어의 시작 부분이므로)
        // 공백이면 패스
        if (i == 0) {
            if (buf[i] != ' ') n++;
            continue;
        }

        // 이전 문자가 공백이고, 현재 문자가 알파벳이면 단어의 시작 부분
        // 따라서 단어의 개수 + 1
        if (buf[i-1] == ' ' && buf[i] != ' ') {
            n++;
        }
    }

    // 2. 단어의 개수 출력
    cout << n << '\n';

}
```

1. cin.getline(buf, 1000001)으로 표준 입력 버퍼에서 문자열 한 번에 받아옴.
    > 종결 문자도 포함해야 하므로 버퍼의 크기는 최대 문자열의 길이(1000000) + 1
2. for문을 돌리면서 단어의 개수 세기
    > 최대 문자열의 길이는 1000000이니, 그만큼 돌기
3. buf[i]가 종결 문자(널 문자)인 경우에는 for문 탈출 
4. i = 0(문자열의 처음 문자 접근)인 경우에는 i-1을 접근할 수 없으므로 따로 처리
    > - buf[i]가 알파벳이면 단어의 시작이므로 단어의 개수 + 1
    > - 그리고 continue (buf[i]가 공백인 경우에는 바로 continue 됨.)
5. 그 외에는 buf[i]와 buf[i-1]을 검사하여 단어의 시작 부분인지 확인

### [장점]
- 표준 입력 버퍼에 한 번만 접근해서 문자열을 한 번에 읽어오므로 빠름.
    > I/O 접근이 적으므로 I/O 접근이 많은 cin.get()을 이용한 방식보다 빠름.
